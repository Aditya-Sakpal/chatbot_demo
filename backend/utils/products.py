import json
from apis_dir.functions import get
from apis_dir.urls import endpoint_fetch_products_n_details, endpoint_fetch_one_product_detail
import traceback
from utils.helpers import log

def fetch_products_n_details(host_url):
    """
        Sends a GET request to the specified endpoint to fetch products and their details for the host URL provided. It then extracts product names and types of information from the response and returns them.

        Args:
            host_url (str): The URL of the host whose product information has to be extracted.
        
        Returns:
            tuple or None: A tuple containing two elements:
                - A list of product names extracted from the response.
                - A list of types of information extracted from the response.
                If the request is successful and the response contains the expected data, the tuple is returned. If there's an error or the response doesn't contain the expected data, None is returned.
    """

    response = get(endpoint_fetch_products_n_details, {"host_url": host_url})
    if response.status_code == 200:
        products = response.json()["data"]["products"]
        types_of_info = response.json()["data"]["types_of_infos"]
        return [product["name"] for product in products], types_of_info

    return None


def get_product_detail(product_name, type_of_info, host_url):
    response = get(endpoint_fetch_one_product_detail,
                   {"host_url": host_url, "name": product_name, "type_of_info": type_of_info})
    if response.status_code == 200:
        return response.json()["data"]

    return ""


def make_tool(host_url):
    """
        Fetches product details for the host using the 'fetch_products_n_details' function. It then constructs OpenAI tools where each tool represents a function to retrieve a specific detail of a product.

        Args:
            host_url (str): The URL of the host whose product information has to be extracted.

        Returns:
            list: A list of dictionaries representing the generated tools. Each dictionary contains information about a specific OpenAI tool, including its type, name, description, and parameters.
    """

    products, type_of_info = fetch_products_n_details(host_url)
    tools = [
        {
            "type": "function",
            "function": {
                "name": "get_product_detail",
                "description": "Get specific detail of a specific product",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "product_name": {
                            "type": "string",
                            "description": "Name of product user is asking about",
                            "enum": products
                        },
                        "type_of_info": {"type": "string",
                                         "description": "What type of information is user looking for about the "
                                                        "product",
                                         "enum": type_of_info},
                    },
                    "required": ["product_name", "type_of_info"],
                },
            },
        }
    ]

    return tools


def make_tool_call(tool_calls, host_url):
    """
        This function processes tool calls retrieved from the OpenAI chat model response.
        It maps each tool call to its corresponding function and executes the function
        with the provided arguments. The function response is then appended to the messages
        list along with metadata such as the tool call ID and function name.

        Args:
            tool_calls (list): A list of tool call objects containing information about the tool functions to be called.

            host_url (str): The URL of the host related to the product information.

        Returns:
            list: A list of dictionaries representing the tool call messages. Each dictionary contains metadata about the tool call (such as ID and name) and the response generated by the corresponding function.

        Raises:
            Exception: If an error occurs during the tool call execution.
    """

    try:
        messages = []

        available_functions = {
            "get_product_detail": get_product_detail,
        }  # only one function in this example, but you can have multiple

        for tool_call in tool_calls:
            function_name = tool_call.function.name
            function_to_call = available_functions[function_name]
            function_args = json.loads(tool_call.function.arguments)
            function_response = function_to_call(
                product_name=function_args.get("product_name"),
                type_of_info=function_args.get("type_of_info"),
                host_url=host_url
            )
            messages.append(
                {
                    "tool_call_id": tool_call.id,
                    "role": "tool",
                    "name": function_name,
                    "content": function_response,
                }
            )  # extend conversation with function response
        return messages
    except Exception as e:
        log("Error in make_tool_call", traceback.format_exc())
        raise e
